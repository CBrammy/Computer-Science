# Introduction to Java

- Manipulating Variables
    
    We covered:
    
    - Addition and subtraction, using `+` and ``
    - Multiplication and division, using `` and `/`
    - The modulo operator for finding remainders, `%`
    - Compound assignment operators `+=`, `=`, `=`, `/=`, and `%=`.
    - The order of operations: parentheses -> exponents -> multiplication, division, modulo -> addition, subtraction
    - Greater than, `>`, and less than, `<`
    - Equal to, `==`, and not equal to, `!=`
    - Greater than or equal to, `>=`, and less than or equal to, `<=`
    - `equals()` for comparing `String`s and other objects
    - Using `+` to concatenate `String`s
    - The `final` keyword which makes variables unchangeable
- Classes
    
    [Cheat sheet](https://www.codecademy.com/learn/learn-java/modules/learn-java-object-oriented-java-u/cheatsheet)
    
    - main class
        
        ```java
        public static void main(String[] args) {
        
        ```
        
    - constructor objects
        
        In order to create an object (an instance of a class), we need a constructor method. The constructor is defined within the class.
        
        ```java
        public class Car {
          // Constructor method
          public Car() {
            // instructions for creating a Car instance
          }  
         
          public static void main(String[] args) {
            // body of main method
          }
        }
        ```
        
        To create an instance, we need to *call* or *invoke* the constructor within `main()`. The following example assigns a `Car` instance to the variable `ferrari`:
        
        ```java
        public class Car {
        
          public Car() {
            // instructions for creating a Car instance
          }
        
          public static void main(String[] args) {
            // Invoke the constructor
            Car ferrari = new Car();
          }
        }
        
        ```
        
    - instance fields
        
        Our last exercise ended with printing an instance of `Store`, which looked something like `Store@6bc7c054`. The first part, `Store`, refers to the class, and the second part `@6bc7c054` refers to the instance’s location in the computer’s memory.
        
        We don’t care about memory location, but our instances have no other characteristics! When an object is created, the constructor sets the initial state of the object. The *state* is made up of associated data that represents the characteristics of an object.
        
        We’ll add data to an object by introducing *instance variables*, or *instance fields*.
        
        We want `Car` instances of different colors, so we declare a `String color` instance field. Often times, instance variables are described as a “has-a” relationship with the object. For example, a `Car` “has-a” `color`. Another way to think of this is that instance variables are the nouns and adjectives associated with an object. What qualities other than `color` might a car *have*?
        
        ```java
        public class Car {
          /*
          declare fields inside the class
          by specifying the type and name
          */
          String color;
        
          public Car() {
            /*
            instance fields available in
            scope of constructor method
            */
          }
        
          public static void main(String[] args) {
            // body of main method
          }
        }
        
        ```
        
    - examples
        
        Dog Class
        
        ```java
        public class Dog {
          // instance field
          String breed;
          // constructor method
          public Dog(String dogBreed) {
            /* 
            value of parameter dogBreed 
            assigned to instance field breed
            */
            breed = dogBreed;
          }
          public static void main(String[] args) {
            /* 
            create instance: 
            use 'new' operator and invoke constructor
            */
            Dog fido = new Dog("poodle");
            /* 
            fields are accessed using: 
            the instance name, `.` operator, and the field name.
            */
            fido.breed;
            // "poodle"
          }
        }
        ```
        
- Methods
    
    The state tells us what a savings account should know:
    
    - The balance of money available
    
    The behavior tells us what tasks a savings account should be able to perform:
    
    - Depositing - increasing the amount available
    - Withdrawing - decreasing the amount available
    - Checking the balance - displaying the amount available.
- Arrays
    - Creating arrays explicitly, using `{` and `}`.
    - Accessing an index of an array using `[` and `]`.
    - Creating empty arrays of a certain size, and filling the indices one by one.
    - Getting the length of an array using `length`.
    - Using the argument array `args` that is passed into the `main()` method of a class.
    
    ```java
    import java.util.Arrays;
    
    public class Classroom {
      
      public static void main(String[] args){
    //Creates an array of strings with names
        String[] students = {"Sade", "Alexus", "Sam", "Koma"};
    // Creates an array containing 4 indexes of doubles
        double[] mathScores = new double[4];
    //Sets index 0 at 94.5
        mathScores[0] = 94.5;
        mathScores[2] = 76.8;
    //Prints out the number of indexes in students array
        System.out.println("The number of students in the class is " + students.length + ".");
      }
    }
    ```
    
- ArrayLists
    - List of commands
        - Creating an `ArrayList`.
        - Adding a new `ArrayList` item using `add()`.
        - Accessing the size of an `ArrayList` using `size()`.
        - Finding an item by index using `get()`.
        - Changing the value of an `ArrayList` item using `set()`.
        - Removing an item with a specific value using `remove()`.
        - Retrieving the index of an item with a specific value using `indexOf()`.
        
        Now if only there were some way to move through an array or `ArrayList`, item by item…
        
    
    To create mutable and dynamic lists, we can use Java’s `ArrayList`s. `ArrayList`s allow us to:
    
    - Store object references as elements
    - Store elements of the same type (just like arrays)
    - Access elements by index (just like arrays)
    - Add elements
    - Remove elements
    
    To create an `ArrayList`, we need to declare the type of objects it will hold, just as we do with arrays:
    
    ```java
    ArrayList<String> babyNames;
    
    ```
    
    We use angle brackets `<` and `>` to declare the type of the `ArrayList`
    
    These symbols are used for *generics*. Generics are a Java construct that allows us to define classes and objects as parameters of an `ArrayList`. For this reason, we can’t use primitive types in an `ArrayList`:
    
    ```
    // This code won't compile:
    ArrayList<int> ages;
    
    // This code will compile:
    ArrayList<Integer> ages;
    
    ```
    
    The `<Integer>` generic has to be used in an `ArrayList` instead. You can also use `<Double>` and `<Char>` for types you would normally declare as `double`s or `char`s.
    
    We can initialize to an empty `ArrayList` using the `new` keyword:
    
    ```java
    // Declaring:
    ArrayList<Integer> ages;
    // Initializing:
    ages = new ArrayList<Integer>();
    
    // Declaring and initializing in one line:
    **ArrayList<String> babyNames = new ArrayList<String>();**
    
    ```
    
    ## ADD FUNCTION
    
    `ArrayList` comes with an `add()` method which inserts an element into the structure. There are two ways we can use `add()`.
    
    If we want to add an element to the end of the `ArrayList`, we’ll call `add()` using only one argument that represents the value we are inserting. In this example, we’ll add objects from the `Car` class to an `ArrayList` called `carShow`:
    
    If we want to add an element at a specific index of our `ArrayList`, we’ll need two arguments in our method call: the first argument will define the index of the new element while the second argument defines the value of the new element:
    
    ```java
    // Insert object corvette at index 1
    carShow.add(1, corvette);
    // carShow now holds [ferrari, corvette, thunderbird, volkswagen]
    
    // Insert object porsche at index 2
    carShow.add(2, porsche);
    // carShow now holds [ferrari, corvette, porsche, thunderbird, volkswagen]
    
    ```
    
    By inserting a value at a specified index, any elements that appear after this new element will have their index value shift over by 1.
    
    Also, note that an error will occur if we try to insert a value at an index that does not exist.
    
    When using `ArrayList`
     methods (like `add()`
    ), the reference parameters and return type of a method must match the declared element type of the `ArrayList`
    . For example, we cannot add an `Integer`
     type value to an `ArrayList`
     of `String`
     elements.
    
    ## SIZE
    
    ```java
    ArrayList<String> shoppingCart = new ArrayList<String>();
     
    shoppingCart.add("Trench Coat");
    System.out.println(shoppingCart.size());
    // 1 is printed
    shoppingCart.add("Tweed Houndstooth Hat");
    System.out.println(shoppingCart.size());
    // 2 is printed
    shoppingCart.add("Magnifying Glass");
    System.out.println(shoppingCart.size());
    // 3 is printed
    ```
    
    ## GET - To access indexed items
    
    For `ArrayList`s, bracket notation won’t work. Instead, we use the method `get()` to access an index:
    
    ```java
    ArrayList<String> shoppingCart = new ArrayList<String>();
    
    shoppingCart.add("Trench Coat");
    shoppingCart.add("Tweed Houndstooth Hat");
    shoppingCart.add("Magnifying Glass");
    
    System.out.println(shoppingCart.get(2));
    
    ```
    
    ## Changing a Value with set()
    
    When we were using arrays, we could rewrite entries by using bracket notation to reassign values:
    
    ```java
    String[] shoppingCart = {"Trench Coat", "Tweed Houndstooth Hat", "Magnifying Glass"};
    
    shoppingCart[0] = "Tweed Cape";
    
    // shoppingCart now holds ["Tweed Cape", "Tweed Houndstooth Hat", "Magnifying Glass"]
    
    ```
    
    `ArrayList` has a slightly different way of doing this, using the `set()` method:
    
    ```java
    ArrayList<String> shoppingCart = new ArrayList<String>();
    
    shoppingCart.add("Trench Coat");
    shoppingCart.add("Tweed Houndstooth Hat");
    shoppingCart.add("Magnifying Glass");
    
    shoppingCart.set(0, "Tweed Cape");
    
    // shoppingCart now holds ["Tweed Cape", "Tweed Houndstooth Hat", "Magnifying Glass"]
    
    ```
    
    ## Remove items with .remove
    
    Luckily, `ArrayList`s allow us to remove an item by specifying the index to remove:
    
    ```
    ArrayList<String> shoppingCart = new ArrayList<String>();
    
    shoppingCart.add("Trench Coat");
    shoppingCart.add("Tweed Houndstooth Hat");
    shoppingCart.add("Magnifying Glass");
    
    shoppingCart.remove(1);
    // shoppingCart now holds ["Trench Coat", "Magnifying Glass"]
    
    ```
    
    We can also remove an item by specifying the value to remove:
    
    ```
    ArrayList<String> shoppingCart = new ArrayList<String>();
    
    shoppingCart.add("Trench Coat");
    shoppingCart.add("Tweed Houndstooth Hat");
    shoppingCart.add("Magnifying Glass");
    
    shoppingCart.remove("Trench Coat");
    // shoppingCart now holds ["Tweed Houndstooth Hat", "Magnifying Glass"]
    
    ```
    
    ## Finding an item’s index with indexOf()
    
    What if we had a really large list and wanted to know the position of a certain element in it? For instance, what if we had an `ArrayList` `detectives` with the names of fictional detectives in chronological order, and we wanted to know what position `"Fletcher"` was.
    
    ```java
    // detectives holds ["Holmes", "Poirot", "Marple", "Spade", "Fletcher", "Conan", "Ramotswe"];
    System.out.println(detectives.indexOf("Fletcher"));
    
    ```
    
- Loops
    
    ## Intro
    
    First, a starting condition is evaluated. If the starting condition is `true`
    , then the loop body is executed. When the last line of the loop body is executed, the condition is *re-evaluated*
    . This process continues until the condition is `false`
     (if the condition never becomes `false`
    , we can actually end up with an **infinite loop**
    !). If the starting condition is `false`
    , the loop never gets executed.
    
    ### Three types of loops that we’ll see everywhere:
    
    - `while` loops
    - `for` loops
    - `for-each` loops
    
    ### While Loops
    
    Like an `if` statement, the code inside a `while` loop will only run if the condition is `true`. However, a `while` loop will continue running the code over and over until the condition evaluates to `false`. So the code block will repeat until `silliness` is less than or equal to 10.
    
    ```java
    // set attempts to 0
    int attempts = 0;
    
    // enter loop if condition is true
    while (passcode != 0524 && attempts < 4) {
    
      System.out.println("Try again.");
      passcode = getNewPasscode();
      attempts += 1;
    
      // is condition still true?
      // if so, repeat code block
    }
    // exit when condition is not true
    
    ```
    
    ### AVOID INFINITE LOOPS
    
    *Infinite loops* occur when the condition will never evaluate to `false`. This can cause your entire program to crash.
    
    ```java
    int hedgehogs = 5;
    
    // This will cause an infinite loop:
    while (hedgehogs < 6) {
    
      System.out.println("Not enough hedgehogs!");
    
    }
    
    ```
    
    **Incrementing While Loops**
    
    When looping through code, it’s common to use a counter variable. A *counter* (also known as an *iterator*) is a variable used in the conditional logic of the loop and (usually) incremented in value during each iteration through the code. For example:
    
    ```java
    // counter is initialized
    int wishes = 0;
    
    // conditional logic uses counter
    while (wishes < 3) {
    
      System.out.println("Wish granted.");
      // counter is incremented
      wishes++;
    
    }
    
    ```
    
    In the above example, the counter `wishes` gets initialized before the loop with a value of `0`, then the program will keep printing `"Wish granted."` and adding `1` to `wishes` as long as `wishes` has a value of less than `3`. Once `wishes` reaches a value of `3` or more, the program will exit the loop.
    
    ### For Loops
    
    Even though we can write `while`
     loops that accomplish the same task, `for`
     loops are useful because they help us remember to increment our counter — something that is easy to forget when we increment with a `while`
     loop.
    
    A `for` *loop* header is made up of the following three parts, each separated by a semicolon:
    
    1. The initialization of the loop control variable.
    2. A `boolean` expression.
    3. An increment or decrement statement.
    
    The opening line might look like this:
    
    ```java
    for (int i = 0; i < 5; i++) {
    
      // code that will run
    
    }
    
    ```
    
    In a `for` loop, an initialization statement is run once in order to initialize the loop control variable. This variable is modified in every iteration, can be referenced in the loop body, and used to test the boolean condition. In the example above, `i` is the loop control variable.
    
    Let’s breakdown the above example:
    
    1. `i = 0`: `i` is initialized to `0`
    2. `i < 5`: the loop is given a `boolean` condition that relies on the value of `i`. The loop will continue to execute until `i < 5` is `false`.
    3. `i++`: `i` will increment at the end of each loop and before the condition is re-evaluated.
        
    ### Iterating Over Arrays and ArrayLists
    
    Traversing an `Array` looks like this:
    
    For example, if we wanted to add `1` to every `int` item in an array `secretCode`, we could do this:
    
    ```java
    for (int i = 0; i < secretCode.length; i++) {
      // Increase value of element value by 1
      secretCode[i] += 1;
    
    ```
    
    Traversing an `ArrayList` looks very similar:
    
    ```java
    for (int i = 0; i < secretCode.size(); i++) {
      // Increase value of element value by 1
      int num = secretCode.get(i);
      secretCode.set(i, num + 1);
    }
    
    ```
    
    We can also use `while` loops to traverse through arrays and `ArrayList`s. If we use a `while` loop, we need to create our own counter variable to access individual elements. We’ll also set our condition to continue looping until our counter variable equals the list length.
    
    For example, let’s use a `while` loop to traverse through an array:
    
    ```java
    int i = 0; // initialize counter
    
    while (i < secretCode.length) {
      secretCode[i] += 1;
      i++; // increment the while loop
    }
    
    ```
    
    Traversing through an `ArrayList` with a `while` loop would look like this:
    
    ```java
    int i = 0; // initialize counter
    
    while (i < secretCode.size()) {
      int num = secretCode.get(i);
      secretCode.set(i, num + 1);
      i++; // increment the while loop
    }
    
    ```
    
    **break and continue**
    
    If we ever want to exit a loop before it finishes all its iterations or want to skip one of the iterations, we can use the `break` and `continue` keywords.
    
    The `break` keyword is used to exit, or break, a loop. Once `break` is executed, the loop will stop iterating. For example:
    
    ```java
    for (int i = 0; i < 10; i++) {
      System.out.println(i);
      if (i == 4) {
        break;
      }
    }
    
    ```
    
    Even though the loop was set to iterate until the condition `i < 10` is `false`, the above code will output the following because we used `break`:
    
    ```java
    0
    1
    2
    3
    4
    ```
    
    The `continue` keyword can be placed inside of a loop if we want to skip an iteration. If `continue` is executed, the current loop iteration will immediately end, and the next iteration will begin. We can use the `continue` keyword to skip any even valued iteration:
    
    ```java
    int[] numbers = {1, 2, 3, 4, 5};
    
    for (int i = 0; i < numbers.length; i++) {
      if (numbers[i] % 2 == 0) {
        continue;
      }
      System.out.println(numbers[i]);
    }
    
    ```
    
    ### For-Each Loops
    
    Sometimes we need access to the elements’ indices or we only want to iterate through a portion of a list. If that’s the case, a regular `for` loop or `while` loop is a great choice.
    
    For example, we can use a `for` loop to print out each element in an array called `inventoryItems`:
    
    ```java
    for (int inventoryItem = 0; inventoryItem < inventoryItems.length; inventoryItem++) {
      // Print element at current index
      System.out.println(inventoryItems[inventoryItem]);
    }
    
    ```
    
    If we want to use a for-each loop to rewrite our program above, the syntax looks like this:
    
    ```java
    for (String inventoryItem : inventoryItems) {
      // Print element value
      System.out.println(inventoryItem);
    
    }
    
    ```
    
    Our enhanced loop contains two items: an enhanced `for` loop variable (`inventoryItem`) and a list to traverse through (`inventoryItems`).
    
    We can read the `:` as “in” like this: for each `inventoryItem` (which should be a `String`) in `inventoryItems`, print `inventoryItem`.
    
    **Removing An Element Using `while`**
    
    When using a `while` loop and removing elements from an `ArrayList`, we should **not** increment the `while` loop’s counter whenever we remove an element. We don’t need to increase the counter because all of the other elements have now shifted to the left.
    
    For example, if we removed the element at index `3`, then the element that was at index `4` will be moved to index `3`. If we increase our counter to `4`, we’ll skip that element!
    
    Take a look at this block of code that will remove all odd numbers from an `ArrayList`. Think about what the value of `i` is, when we’re increasing the value of `i`, and when `i < lst.size()` becomes `False`.
    
    ```java
    int i = 0; // initialize counter
    
    while (i < lst.size()) {
      // if value is odd, remove value
      if (lst.get(i) % 2 != 0){
        lst.remove(i);
      } else {
        // if value is even, increment counter
        i++;
      }
    }
    
    ```
    
    ### **Removing An Element Using `for`**
    
    We can use a similar strategy when removing elements using a `for` loop. When using a `while` loop, we decided to not increase our loop control variable whenever we removed an element. This ensured that we would not skip an element when all of the other elements shifted to the left.
    
    When using a `for` loop, we, unfortunately, *must* increase our loop control variable — the loop control variable will always change when we reach the end of the loop (and it will usually change by `1` because we often use something like `i++`.) Since we can’t avoid increasing our loop control variable, we can take matters into our own hands and decrease the loop control variable whenever we remove an item.
    
    For example:
    
    ```java
    for (int i = 0; i < lst.size(); i++) {
      if (lst.get(i) == "value to remove"){
        // remove value from ArrayList
        lst.remove(lst.get(i));
        // Decrease loop control variable by 1
        i--;
      }
    }
    
    ```
    
    Now whenever we remove an item, we’ll decrease `i` by `1`. Then when we reach the end of the loop, `i` will increase by `1`. It will be like `i` never changed!
    
    **Note:** Avoid manipulating the size of an `ArrayList` when using an enhanced `for` loop. Actions like adding or removing elements from an `ArrayList` when using a `for each` loop can cause a `ConcurrentModificationException` error.
    
    **Review**
    
    Nice work! Let’s iterate over what you’ve just learned about loops:
    
    - `while` loops: These are useful to repeat a code block an unknown number of times until some condition is met. For example:
    
    ```java
    int wishes = 0;
    
    while (wishes < 3) {
    
      // code that will run
      wishes++;
    
    }
    
    ```
    
    - `for` loops: These are ideal for when you are incrementing or decrementing with a counter variable. For example:
    
    ```java
    for (int i = 0; i < 5; i++) {
    
      // code that will run
    
    }
    
    ```
    
    - For-each loops: These make it simple to do something with each item in a list. For example:
    
    ```java
    for (String inventoryItem : inventoryItems) {
    
      // do something with each inventoryItem
    
    }
    
    ```
    
    ****
    
- String Methods
    
    Because character strings are so vital to programming, Java dedicated an entire class to them. This is great news for us because the `String` class has a lot of useful methods to help us perform operations on `Strings` and data manipulation. We don’t have to import anything to use the `String` class because it’s part of the `java.lang` package which is available by default.
    
    In this lesson, we will go over several `String` methods:
    
    - `length()`
    - `concat()`
    - `equals()`
    - `indexOf()`
    - `charAt()`
    - `substring()`
    - `toUpperCase()` / `toLowerCase()`
    
    **concat()**
    
    str1.concat(str2) concatenates boths strings together
    
    **equals()**
    
    With objects, such as `String`s, we can’t use the primitive equality operator `==` to check for equality between two strings. To test equality with strings, we use a built-in method called `equals()`
    
    **indexOf()**
    
    If we want to know the index of the first occurence of a character in a string, we can use the `indexOf()` method on a string.
    
    If the `indexOf()`
     doesn’t find what it’s looking for, it’ll return a `-1`
    
    **charAt()**
    
    The `charAt()` method returns the character located at a `String`‘s specified index.
    
    For example:
    
    ```java
    String str = "qwer";
    
    System.out.println(str.charAt(2));
    
    ```
    
    It would output `e` because that’s what’s at index 2. (Once again, indices start with 0.)
    
    Suppose we try to return the character located at index 4. It would produce an `IndexOutOfBoundsException` error because index 4 is out of `str`‘s range:
    
    ```java
    java.lang.StringIndexOutOfBoundsException: String index out of range: 4
    ```
    
    **substring()**
    
    There may be times when we only want a part of a string. In such cases, we may want to extract a *substring* from a string.
    
    The `substring()` method does exactly that. For example:
    
    ```java
    String line = "The Heav'ns and all the Constellations rung";
    
    System.out.println(line.substring(24));
    
    ```
    
    Suppose we want a substring from the middle of the string. We can instead include two arguments in this method. For example:
    
    ```java
    String line = "The Heav'ns and all the Constellations rung";
    
    System.out.println(line.substring(27, 33));
    
    ```
    
    When `substring()` is called with two arguments, the first argument is *inclusive* and the second is *exclusive*. This means the resulting substring will begin at index 27 and extend up to, but *not* including, index 33. Therefore, the example above would output `stella` because that’s the substring that begins at index 27 and ends at index 32, one index before 33.
    
- Access, Encapsulation and Scope
    
    Why don’t I just make everything `public`?”
    
    While those are valid points, sometimes restricting our code is actually useful from a design perspective. This is one of the core ideas behind *encapsulation*. By making our instance variables (and some methods) `private`, we encapsulate our code into nice little bundles of logic.
    
    **Accessor and Mutator Methods**
    
    When writing classes, we often make all of our instance variables `private`. However, we still might want some other classes to have access to them, we just don’t want those classes to know the *exact* variable name. To give other classes access to a private instance variable, we would write an *accessor method* (sometimes also known as a “getter” method).
    
    ```java
    public class Dog{
      private String name;
    
      //Other methods and constructors
    
      public String getName() {
        return name;
      }
    }
    
    ```
    
    Even though the instance variable `name` is `private`, other classes could call the `public` method `getName()` which returns the value of that instance variable. Accessor methods will always be `public`, and will have a return type that matches the type of the instance variable they’re accessing.
    
    Similarly, `private` instance variables often have mutator methods (sometimes known as “setters”). These methods allow other classes to reset the value stored in `private` instance variables.
    
    ```java
    public class Dog{
      private String name;
    
      //Other methods and constructors
    
      public void setName(String newName) {
        name = newName;
      }
    
      public static void main(String[] args){
        Dog myDog = new Dog("Cujo");
        myDog.setName("Lassie");
      }
    }
    
    ```
    
    Mutator methods, or “setters”, often are `void` methods — they don’t return anything, they just reset the value of an existing variable. Similarly, they often have one parameter that is the same type as the variable they’re trying to change.
    
     
    
    ### Scope
    
    Oftentimes, you’ll see constructors have parameters with the same name as the instance variable. For example, you might see something like:
    
    ```java
    public Dog(String name){
      this.name = name;
    }
    ```
    
    You can read this as “set `this` `Dog`‘s instance variable `name` equal to the variable passed into the constructor”. While this naming is a common convention, it can also be confusing. There’s nothing wrong with naming your parameters something else to be more clear. Sometimes you will see something like:
    
    ```java
    public Dog(String inputName){
      this.name = inputName;
    }
    ```
    
    This is now a little clearer — we’re setting the `Dog`‘s instance variable `name` equal to the name we give the constructor
    
    Finally, mutator methods also usually follow this pattern:
    
    ```java
    public void setName(String name){
      this.name = name;
    }
    
    ```
    
    We reset the instance variable to the value passed into the parameter
    
- Math Class
    
    • The **`Math`** class is part of the **`java.lang`** package and provides useful static methods for performing mathematical equations.
    
    - Random
        
        ### **double random()**
        
        **Purpose:** Returns a double value greater than or equal to **`0.0`** and less than **`1.0`**
        
        Randomization is a great way to add probability to our programs. There are many ways to implement **`Math.random()`** in Java. Its default use case is to produce a random **`double`** value between **`0.0`** and **`1.0`**. For example:
        
        ```
        System.out.println(Math.random());
        System.out.println(Math.random());
        System.out.println(Math.random());
        
        ```
        
        The random values can change every time we run our program. An example output of the above program is the following:
        
        ```
        0.8592007008856128
        0.6120058754881421
        0.48259656765819403
        
        ```
        
        With some manipulation, we can use **`Math.random()`** to create a random **`int`** or **`double`** value within a predefined range.
        
        For example, if we wanted a random **`double`** value between **`0`** and **`9`**, we would multiply **`Math.random()`** by **`10`**
        
        ```
        // Random double value between 0 and 9
        double a = Math.random() * 10;
        
        ```
        
        If we wanted a random **`int`** value between **`0`** and **`9`**, we would need to implement the **`(int)`** casting operator in our expression like so:
        
        ```
        // Random int value between 0 and 9
        int b = (int)(Math.random() * 10);
        
        ```
        
        If we wanted our range to start at **`1`** and end at **`10`**, we would have to add **`1`** to the end of our previous expression:
        
        ```
        // Random int value between 1 and 10
        int c = (int)(Math.random() * 10) + 1;
        
        ```
        
        Using addition also gives us the ability to start the range at any number. What if we wanted an **`int`** value in the range of **`10`** up to and including **`20`**? We would have to implement the algorithm **`(Math.random() * (maxValue - minValue + 1)) + minValue`**.
        
        For example:
        
        ```
        // Random int value between 10 and 20
        int d = (int)(Math.random() * 11 ) + 10;
        
        ```
        
        We multiple **`Math.random()`** by **`11`** because **`20`** (our max value) minus **`10`** (our minimum value) plus **`1`** is **`11`**. We add **`+ 10`** outside the parentheses so that our smallest value is guaranteed to be **`10`**.
        
        Here’s another way to think about this algorithm — the value that you multiply by defines the number of possible values you can get. The number that you add defines the starting value. So, for example, **`(int)(Math.random() * 3 ) + 5;`** will give you one of three random values starting at **`5`**. So this could give you **`5`**, **`6`**, or **`7`**.
        
        Finally, be careful of off-by-one errors when using **`Math.random()`**. For example, you might write some code that you think generates a number between 1 and 10, but it actually generates a number between 1 and 9. Be sure to test your code frequently to sport logical errors like these!
        
        ### **`(Math.random() * (maxValue - minValue + 1)) + minValue`**
        
    
- Static Variables
    
    **Static Variables**
    
    Much like static methods, you can think of *static variables* as belonging to the class itself instead of belonging to a particular object of the class.
    
    You can think of it as all objects of the class sharing the same variable
    
    ```java
    public class Dog{
     
      // Static variables
      public static String genus = "Canis";
     
      //Instance variables
      public int age;
      public String name;
     
      public Dog(int inputAge, String inputName){
        this.age = inputAge;
        this.name = inputName;
      }
    public static void main(String[] args){
      Dog snoopy = new Dog(3, "Snoopy");
      Dog ringo = new Dog(5, "Ringo");
        System.out.println(Dog.genus); // Prints Canis
      System.out.println(Dog.genus); // Prints Canis
      System.out.println(snoopy.genus); // Prints Canis
      System.out.println(ringo.genus); // Prints Canis
    }
    
    ```
    
    Great work! You now have an understanding of what the `static` keyword does. In fact, if you’ve made it this far in your Java lessons, you probably have a pretty good sense of what all the keywords and jargon are doing in `public static void main(String[] args)`. Take a moment to celebrate — that line of code can be incredibly intimidating for new learners and it’s a real accomplishment to learn about all of those different pieces.
    
    To review, here are some of the main takeaways about static methods and variables:
    
    - Static methods and variables are associated with the class as a whole, not objects of the class.
    - Static methods and variables are declared as static by using the `static` keyword upon declaration.
    - Static methods cannot interact with non-static instance variables. This is due to static methods not having a `this` reference.
    - Both static methods and non-static methods can interact with static variables.
- Inheritence and Polymorphism
    
    **Review of Inheritance and Polymorphism**
    
    Excellent work! You’ve learned quite a bundle about inheritance and polymorphism in Java:
    
    - A Java class can inherit fields and methods from another class.
    - Each Java class requires its own file, but only one class in a Java package needs a `main()` method.
    - Child classes inherit the parent constructor by default, but it’s possible to modify the constructor using `super()` or override it completely.
    - You can use `protected` and `final` to control child class access to parent class members.
    - Java’s OOP principle of polymorphism means you can use a child class object like a member of its parent class, but also give it its own traits.
    - You can override parent class methods in the child class, ideally using the `@Override` keyword.
    - It’s possible to use objects of different classes that share a parent class together in an array or `ArrayList`.
    
    **Inheritance in Practice**
    
    So how do we define a child class so that it inherits from a parent class? We use the keyword `extends` like this:
    
    ```java
    class Shape {
    
      // Shape class members
    
    }
    
    class Triangle extends Shape {
    
      // additional Triangle class members
    
    }
    ```
    
    When we use inheritance to extend a subclass from a superclass, we create an “is-a” relationship from the subclass to the superclass. For example, an object of `Triangle`
     *is a* member of the `Shape`class; however, an object of `Shape` is not necessarily an object of `Triangle`
    
    **Inheriting the Constructor**
    
    Hang on, you might be thinking, if the child class inherits its parent’s fields and methods, does it also inherit the constructor? Let’s take a look at how the `super()` constructor works!
    
    Let’s say `Shape` has a `numSides` field that is set by passing an integer into the constructor. If we’re instantiating a `Triangle`, we would want that number to always be `3`, so we’d want to modify the constructor to automatically assign `numSides` with a value of `3`.
    
    Can we do that?
    
    As it happens, Java has a trick up its sleeve for just this occasion: using the `super()` method which acts like the parent constructor inside the child class constructor:
    
    ```java
    class Triangle extends Shape {
    
      Triangle() {
        super(3);
      }
    
      // additional Triangle class members
    
    }
    ```
    
    By passing `3` to `super()`, we are making it possible to instantiate a `Triangle` without passing in a value for `numSides`.
    
    Meanwhile, `super(3)` (behaving as `Shape(3)`) will shoulder the responsibility of setting `numSides` to `3` for our `Triangle` object. It’s like we called `Shape(3)`.
    
    It is also possible to write a constructor without making a call to any `super()` constructor:
    
    ```java
    class Triangle extends Shape {
    
      Triangle() {
        this.numSides = 3;
      }
    
      // additional Triangle class methods
    
    }
    ```
    
    In this situation, Java secretly calls the parent class’ no-argument constructor (`super()`). So in this specific example, the `Triangle()` constructor first calls the `Shape()` constructor. That `Shape()` takes care of whatever business it needs to take care of. And then after that is complete, we go in and set `this.numSides` to `3`.
    
    It is also possible to write a constructor without making a call to any `super()` constructor:
    
    ```java
    class Triangle extends Shape {
    
      Triangle() {
        this.numSides = 3;
      }
    
      // additional Triangle class methods
    
    }
    
    ```
    
    In this situation, Java secretly calls the parent class’ no-argument constructor (`super()`). So in this specific example, the `Triangle()` constructor first calls the `Shape()` constructor. That `Shape()` takes care of whatever business it needs to take care of. And then after that is complete, we go in and set `this.numSides` to `3`.
    
    If you’re writing a constructor of a child class, and don’t explicitly make a call to a constructor from a parent class using `super`, it’s important to remember that Java will automatically (and secretly) call `super()` as the first line of your child class constructor.
    
    **Parent Class Aspect Modifiers**
    
    You may recall that Java class members use `private` and `public` access modifiers to determine whether they can be accessed from outside the class. So does a child class inherit its parent’s `private` members?
    
    Well, no. But there is another access modifier we can use to keep a parent class member accessible to its child classes and to files in the package it’s contained in — and otherwise private: `protected`.





    
    Introducing Polymorphism**
  
    
    In Java, if `Orange` is a `Fruit` through inheritance, you can then use `Orange` in the same contexts as `Fruit` like this:
    
    ```
    String makeJuice(Fruit fruit) {
    
      return "Apple juice and " + fruit.squeeze();
    
    }
    
    // inside main()
    Orange orange = new Orange();
    System.out.println(juicer.makeJuice(orange));
    
    ```
    
    Wait, how does that work?
    
    This is because Java incorporates the object-oriented programming principle of *polymorphism*. Polymorphism, which derives from Greek meaning “many forms”, allows a child class to share the information and behavior of its parent class while also incorporating its own functionality.
    
    The main advantages of polymorphic programming:
    
    - Simplifying syntax
    - Reducing cognitive overload for developers
    - 
    
    **Child Classes in Arrays and ArrayLists**
    
    Usually, when we create an array or an `ArrayList`, the list items all need to be the same type. But polymorphism puts a new spin on what is considered the same type…
    
    In fact, we can put instances of different classes that share a parent class together in an array or `ArrayList`! For example, let’s say we have a `Monster` parent class with a few child classes: `Vampire`, `Werewolf`, and `Zombie`. We can set up an array with instances of each:
    
    ```
    Monster dracula, wolfman, zombie1;
    
    dracula = new Vampire();
    wolfman = new Werewolf();
    zombie1 = new Zombie();
    
    Monster[] monsters = {dracula, wolfman, zombie1};
    
    ```
    
    We can even iterate through the list of items — regardless of subclass — and perform the same action with each item:
    
    ```
    for (Monster monster : monsters) {
    
      monster.attack();
    
    }
    ```
    
    In the code above, we were able to call `attack()` on each monster in `monsters` despite the fact that, in the for-each loop, `monster` is declared as the parent class type `Monster`.
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bf7b8202-d605-4967-ac8a-cf0f266666b1/Untitled.png)
    
- Debugging
    
    In Java, there are many different ways of classifying errors, but they can be boiled down to three categories:
    
    - **Syntax errors:** Errors found by the compiler.
    - **Run-time errors:** Errors that occur when the program is running.
    - **Logic errors:** Errors found by the programmer looking for the causes of erroneous results.
    
    Some common exceptions that you will see in the wild:
    
    - `ArithmeticException`: Something went wrong during an arithmetic operation; for example, division by zero.
    - `NullPointerException`: You tried to access an instance variable or invoke a method on an object that is currently `null`.
    - `ArrayIndexOutOfBoundsException`: The index you are using is either negative or greater than the last index of the array (i.e., `array.length-1`).
    - `FileNotFoundException`: Java didn’t find the file it was looking for.
        
        **Exception Handling**
        
        Exception handling is an essential feature of Java programming that allows us to use run-time error exceptions to make our debugging process a little easier.
        
        One way to handle exceptions is using the `try`/`catch`:
        
        - The `try` statement allows you to define a block of code to be tested for errors while it is being executed.
        - The `catch` statement allows you to define a block of code to be executed if an error occurs in the try block.
        
        The `try` and `catch` keywords come in pairs, though you can also catch several types of exceptions in a single block:
        
        ```java
        try {
        
          //  Block of code to try
        
        } catch (NullPointerException e) {
        
          // Print the error message like this:
          System.err.println("NullPointerException: " + e.getMessage());
        
          // Or handle the error another way here
        
        }
        
        ```
        
        Notice how we used `System.err.println()` here instead of `System.out.println()`. `System.err.println()` will print to the standard error and the text will be in red.
        
        You can also chain exceptions together:
        
        ```java
        try {
        
          //  Block of code to try
        
        } catch (NullPointerException e) {
        
          //  Code to handle a NullPointerException
        
        } catch (ArithmeticException e) {
        
          //  Code to handle an ArithmeticException
        
        }
        
        ```
        
- Two-Dimensional Arrays
    
    **Introduction to 2D Arrays**
    
    As we have learned previously, an array is a group of data consisting of the same type. This means that we can have an array of primitive data types (such as integers):
    
    ```
    [1, 2, 3, 4, 5]
    ```
    
    We can even have an array of Objects. For example, the following example shows an array of String Objects:
    
    ```
    ["hello", "world", "how", "are", "you"]
    ```
    
    In Java, arrays are considered Objects; therefore, we can also have an array of arrays:
    
    ```
    [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    ```
    
    These are called 2D arrays since we can logically view them as a two-dimensional matrix of values containing both rows and columns.
    

    Additionally, we can have 2D arrays which are not rectangular in shape. These are called jagged arrays:
    
    ```
    [['a', 'b', 'c', 'd'], ['e', 'f'], ['g', 'h', 'i', 'j'], ['k']]
    
    ```
    
    ![https://static-assets.codecademy.com/Paths/ap-computer-science/TwoDArrays/jagged.png](https://static-assets.codecademy.com/Paths/ap-computer-science/TwoDArrays/jagged.png)
    
    We won’t be covering jagged arrays in this lesson, but be aware that 2D arrays don’t always have to have the same number of subarrays in each array. This would cause the shape of the 2D array to not be rectangular.
    
    Why use 2D arrays?
    
    - It is useful to use 2D arrays for situations where you need to store and organize data by rows and columns. For example, exporting data to be used in a spreadsheet.
    - You can condense multiple arrays down to a single variable using 2D arrays. For example, if you have 10 students who each have 10 different quiz grades, you can represent the overall class quiz grades as a 10x10 2D array by having each row represent a student and each column represent one of the quizzes they have taken.
    - 2D arrays can be used to map out data. For example, if you want to create a game of tic-tac-toe, you can represent the game state by using a 3x3 2D array.
    
    There are many other ways to use 2D arrays depending on the application. **The only downside is that once initialized, no new rows or columns can be added or removed without copying the data to a newly initialized 2D array**. This is because the length of arrays in Java are immutable (unable to be changed after creation).
    
    **Declaration, Initialization, and Assignment**
    
    When declaring 2D arrays, the format is similar to normal, one-dimensional arrays, except that you include an extra set of brackets after the data type. In this example, `int` represents the data type, the first set of brackets `[]` represent an array, and the second set of brackets `[]` represent that we are declaring an array of arrays.
    
    ```
    int[][] intTwoDArray;
    ```
    
    You can think of this as creating an array (`[]`) of int arrays (`int[]`). So we end up with `int[][]`.
    
    Now that we’ve declared a 2D array, let’s look at how to initialize it with starting values. When initializing arrays, we define their size. Initializing a 2D array is different because, instead of only including the number of elements in the array, you also indicate how many elements are going to be in the sub-arrays. This can also be thought of as the number of rows and columns in the 2D matrix.
    
    ```
    int[][] intArray1;
    intArray1 = new int[row][column];
    ```
    
    Here is an example of initializing an empty 2D array with 3 rows and 5 columns.
    
    ```
    int[][] intArray2;
    intArray2 = new int[3][5];
    ```
   
    If you already know what values are going to be in the 2D array, you can initialize it and write all of the values into it at once. We can accomplish this through initializer lists
    
    - In Java, initializer lists are a way of initializing arrays and assigning values to them at the same time
    - We can use this for 2D arrays as well by creating an initializer list of initializer lists
    
    An example of an initializer list for a regular array would be:
    
    ```
    char[] charArray = {'a', 'b', 'c', 'd'};
    ```
    
    Similar to how a regular initializer list defines the size and values of the array, nested initializer lists will define the number of rows, columns, and the values for a 2D array.
    
    There are three situations in which we can use initializer lists for 2D arrays:
    
    1. In the case where the variable has not yet been declared, we can provide an abbreviated form since Java will infer the data type of the values in the initializer lists:
        
        ```
        double[][] doubleValues = {{1.5, 2.6, 3.7}, {7.5, 6.4, 5.3}, {9.8,  8.7, 7.6}, {3.6, 5.7, 7.8}};
        ```
        
    2. If the variable has already been declared, you can initialize it by creating a `new` 2D array object with the initializer list values:
        
        ```
        String[][] stringValues;
        stringValues = new String[][] {{"working", "with"}, {"2D", "arrays"}, {"is", "fun"}};
        ```
        
    3. The previous method also applies to assigning a new 2D array to an existing 2D array stored in a variable.
    
    TIC TAC TOE 2D Array
    
    ```java
    //Initalize a tic tac toe board
        char[][] ticTacToe = {{'X', 'O', 'O'}, {'O', 'X', ' '}, {'X', ' ', 'X'}};
    // Replace X's with O's and vice versa
        ticTacToe = new char[][] {{'O', 'X', 'X'}, {'X', 'O', ' '}, {'O', ' ', 'O'}};
    ```
    
    **Modifying Elements in a 2D Array**
    
    Let’s say we wanted to replace four values from a new 2D array called `intTwoD`. Look at this example code to see how to pick individual elements and assign new values to them.
    
    ```
    int[][] intTwoD = new int[4][3];
    
    intTwoD[3][2] = 16;
    intTwoD[0][0] = 4;
    intTwoD[2][1] = 12;
    intTwoD[1][1] = 8;
    
    ```
    
    Here is a before and after image showing when the 2D array was first initialized compared to when the four elements were accessed and modified.
    
    **Nested Loops**
    
    Here is an example using **for** loops:
    
    ```
    for(int outer = 0; outer < 3; outer++){
        System.out.println("The outer index is: " + outer);
        for(int inner = 0; inner < 4; inner++){
            System.out.println("\tThe inner index is: " + inner);
        }
    }
    
    ```
    
    The output of the above nested loops looks like so:
    
    ```
    The outer index is: 0
        The inner index is: 0
        The inner index is: 1
        The inner index is: 2
        The inner index is: 3
    The outer index is: 1
        The inner index is: 0
        The inner index is: 1
        The inner index is: 2
        The inner index is: 3
    The outer index is: 2
        The inner index is: 0
        The inner index is: 1
        The inner index is: 2
        The inner index is: 3
    
    ```
    
    From this example we can see how every time the outer loop iterates one time, the inner loop iterates fully.
    
    This is an important concept for 2D array traversal, because for every row in a two dimensional matrix, we want to iterate through every column. We will look more at this in the next exercise.
    
    Nested loops can consist of any type of loop and with any combination of loops. Let’s take a look at a few more interesting examples.
    
    Here is an example of nested while loops:
    
    ```
    int outerCounter = 0;
    int innerCounter = 0;
    while(outerCounter<5){
        outerCounter++;
        innerCounter = 0;
        while(innerCounter<7){
            innerCounter++;
        }
    }
    
    ```
    
    We can even have some interesting combinations. Here is an enhanced **for** loop inside of a while loop:
    
    ```
    int outerCounter = 0;
    int[] innerArray = {1,2,3,4,5};
    
    while(outerCounter<7){
        System.out.println();
        for(int number : innerArray){
            System.out.print(number * outerCounter + " ");
        }
        outerCounter++;
    }
    
    ```
    
    The output of the above example creates a multiplication table:
    
    ```
    0 0 0 0 0
    1 2 3 4 5
    2 4 6 8 10
    3 6 9 12 15
    4 8 12 16 20
    5 10 15 20 25
    6 12 18 24 30
    
    ```
    
    NEST LOOPS - TICKETS DAY ONE & TWO (CHECK FOR MATCHING ELEMENTS IN BOTH ARRAYS)
    
    ```java
    public class NestedLoops {
    	public static void main(String[] args) {
    		int[] seatsDayOne = {850007, 841141, 150017, 622393, 178505, 952093, 492450, 790218, 515994, 926666, 476090, 709827, 908660, 718422, 641067, 624652, 429205, 394328, 802772, 468793, 901979, 504963, 733939, 706557, 724430, 663772, 577480, 886333, 323197, 283056, 378922, 628641, 494605, 606387, 179993, 755472, 253608, 975198, 328457, 885712, 411958, 418586, 254970, 299345, 632115, 915208, 661570, 328375, 538422, 321303};
        
    		int[] seatsDayTwo = {740912, 209431, 310346, 316462, 915797, 850440, 803140, 459194, 293277, 302424, 790507, 711980, 639916, 707446, 940339, 613076, 524157, 189604, 595934, 509691, 234133, 787575, 674602, 944308, 710345, 889699, 622393, 151931, 964325, 944568, 357684, 933857, 541190, 935076, 468848, 449446, 278951, 885503, 539124, 278723, 998622, 846182, 394328, 914002, 803795, 851135, 828760, 504936, 504322, 648644};
    		
    		int matchCounter = 0;
    		// Fix the outer loop header to iterate through the first array of seats
    		for(int i = 0; i < seatsDayOne.length; i++) {
    
    			// Fix the inner loop header to iterate through the second array of seats
    			for(int j = 0; j < seatsDayTwo.length; j++) {
    
    				// Replace 1==2 with conditional logic to check if an element in the first array matches an element in the second array
    				if(seatsDayOne[i]==seatsDayTwo[j]) {
    					matchCounter++;
    					System.out.println("Contestant: " + seatsDayOne[i] + ", Seat Day One: " + i + ", Seat Day Two: " + j);
    					break;
    				}
    			}
    		}
    		System.out.println("The total number of contestants reserving seats on both days was: " + matchCounter);
    	}
    }
    ```
    
    **Traversing 2D Arrays: Introduction**
    
    In the last exercise, we reviewed how to use nested loops as well as how to iterate through regular arrays using loops. In this exercise, we will apply that knowledge in order to learn how to traverse 2D arrays.
    
    Traversing 2D arrays using loops is important because it allows us to access many elements quickly, access elements in very large 2D arrays, and even access elements in 2D arrays of unknown sizes.
    
    Let’s remember the structure of 2D arrays in Java:
    
    ```
    char[][] letterBlock = {{'a','b','c'},{'d','e','f'},{'g','h','i'},{'j', 'k', 'l'}};
    
    ```
    
    In Java, 2D arrays are like normal arrays, but each element is another array. This is shown by the initialized 2D array above. The outer array consists of four elements, where each element consists of a three element subarray.
    
    Let’s see what happens when we access elements of the outer array
    
    ```
    System.out.println(Arrays.toString(letterBlock[0]) + "\n");
    System.out.println(Arrays.toString(letterBlock[1]) + "\n");
    System.out.println(Arrays.toString(letterBlock[2]) + "\n");
    System.out.println(Arrays.toString(letterBlock[3]) + "\n");
    
    ```
    
    Here is the output of the above code:
    
    ```
    [a, b, c]
    
    [d, e, f]
    
    [g, h, i]
    
    [j, k, l]
    
    ```
    
    Let’s take a look at an example which produces the same output, but can handle any sized 2D array.
    
    ```
    for(int index = 0; index < letterBlock.length; index++){
        System.out.println(Arrays.toString(letterBlock[index]) + "\n");
    }
    
    ```
    
    Here is the result:
    
    ```
    [a, b, c]
    
    [d, e, f]
    
    [g, h, i]
    
    [j, k, l]
    
    ```
    
    Now let’s remember how to access a value from the subarray. Previously, we learned that we can use the double brackets `[][]`, where the first set of brackets contains the index of the element of the outer array and the second set of brackets contains the index of the element in the subarray. If we wanted to retrieve the letter `'f'` we would use:
    
    `char storedLetter = letterBlock[1][2];`
    
    Since we know we can use a loop to retrieve each of the subarrays stored in the outer array, we can then use a nested loop to access each of the elements from the sub-array.
    
    You might be wondering how we can figure out the number of iterations needed in order to fully traverse the 2D array.
    
    - In order to find the number of elements in the outer array, we just need to get the length of the 2D array.
        - `int lengthOfOuterArray = letterBlock.length;`
        - When thinking about the 2D array in matrix form, this is the height of the matrix (the number of rows)
    - In order to find the number of elements in the subarray, we can get the length of the subarray after it has been retrieved from the outer array.
        - Remember that we retrieved the sub array earlier using this format:
            - `char[] subArray = letterBlock[0];`
        - Therefore, we can use this to get the length of the first subarray in the 2D array
            - `int lengthOfSubArray = letterBlock[0].length;`
            - When thinking about the 2D array in matrix form, this is the width of the matrix (the number of columns)
        - In most cases, getting the length of the first subarray in the 2D array will apply to the rest of the subarrays (if it is rectangular in shape), but there are rare occasions where the length of the subarrays could be different. This occurs if the 2D array is a jagged array. We won’t be working with any jagged 2D arrays in this lesson, but it’s something to keep in mind.
    
    Let’s look at an example!
    
    ```
    for(int a = 0; a < letterBlock.length; a++) {
        for(int b = 0; b < letterBlock[a].length; b++) {
            System.out.print("Accessed: " + letterBlock[a][b] + "\t");
        }
        System.out.println();
    }
    
    ```
    
    You can think of the variable `a` as being the outer loop index, and the variable `b` as being the inner loop index.
    
    Here is the output:
    
    ```
    Accessed: a    Accessed: b    Accessed: c
    Accessed: d    Accessed: e    Accessed: f
    Accessed: g    Accessed: h    Accessed: i
    
    ```
    
    Within the nested **for** loop, we can see that each of the subarray elements are being accessed by using the outer loop index for the outer array, and the inner loop index for the subarray.
    
    We don’t have to only use regular **for** loops for traversing 2D arrays. We can use enhanced **for** loops if we do not need to keep track of the indices. Since enhanced **for** loops only use the element of the arrays, it is a bit more cumbersome to keep track of which index we are at. This same idea applies to while and do-while loops as well. This is why we usually use regular **for** loops except for when we want to do something simple like printing.
    
    We have gone over how to think about 2D array traversal in terms of arrays of arrays, but there are two main ways of thinking about traversal in terms of rows and columns. These are called row-major order and column-major order.
    
    **Sum of All of 2D Array, Iterating Through All To Sum**
    
    ```java
    public class Introduction {
    	public static void main(String[] args) {
    		//Given the provided 2d array
    		int[][] intMatrix = {
    				{ 4,  6,  8, 10, 12, 14, 16},
    				{18, 20, 22, 24, 26, 28, 30},
    				{32, 34, 36, 38, 40, 42, 44},
    				{46, 48, 50, 52, 54, 56, 58},
    				{60, 62, 64, 66, 68, 70, 79}
    		};
    		// Store the number of subarrays of intMatrix into a variable called 'numSubArrays'
        int numSubArrays = intMatrix.length;
    		
    		// Store the length of the subarrays using the first subarray in intMatrix. Store it in a variable called subArrayLength.
    		int subArrayLength = intMatrix[0].length;
    		// Store the number of columns in intMatrix into a variable called 'columns'
        int columns = subArrayLength;
    		
    		// Store the number of rows in intMatrix into a variable called 'rows'
    		int rows = numSubArrays;
    		// Replace the outer and inner for loop headers to iterate through the entire 2D array. Use the iterators `i` for the outer loop and `j` for the inner loop.
    		int sum = 0;
    		for(int i=0; i< intMatrix.length; i++) {
    			for(int j = 0; j < intMatrix[i].length; j++) {
    
    				// Insert a line of code to increase the variable `sum` by each accessed element
    				sum += intMatrix[i][j];
    			}
    		}
    		System.out.println(sum);
    	}
    }
    ```
    
    **Traversing 2D Arrays: Row-Major Order**
    
    Row-major order for 2D arrays refers to a traversal path which moves horizontally through each row starting at the first row and ending with the last.
    
    Although we have already looked at how 2D array objects are stored in Java, this ordering system conceptualizes the 2D array into a rectangular matrix and starts the traversal at the top left element and ends at the bottom right element.
    
    This path is created by the way we set up our nested loops. In the previous exercise, we looked at how we can traverse the 2D array by having nested loops in a variety of formats, but if we want to control the indices, we typically use standard **for** loops.
    
    Let’s take a closer look at the structure of the nested **for** loops when traversing a 2D array:
    
    Given this 2D array of strings describing the element positions:
    
    ```
    String[][] matrix = {{"[0][0]", "[0][1]", "[0][2]"},
                         {"[1][0]", "[1][1]", "[1][2]"},
                         {"[2][0]", "[2][1]", "[2][2]"},
                         {"[3][0]", "[3][1]", "[3][2]"}};
    
    ```
    
    Lets keep track of the total number of iterations as we traverse the 2D array:
    
    ```
    int stepCount = 0;
    
    for(int a = 0; a < matrix.length; a++) {
        for(int b = 0; b < matrix[a].length; b++) {
            System.out.print("Step: " + stepCount);
            System.out.print(", Element: " + matrix[a][b]);
            System.out.println();
            stepCount++;
        }
    }
    
    ```
    
    Here is the output of the above code:
    
    ```
    Step: 0, Element: [0][0]
    Step: 1, Element: [0][1]
    Step: 2, Element: [0][2]
    Step: 3, Element: [1][0]
    Step: 4, Element: [1][1]
    Step: 5, Element: [1][2]
    Step: 6, Element: [2][0]
    Step: 7, Element: [2][1]
    Step: 8, Element: [2][2]
    Step: 9, Element: [3][0]
    Step: 10, Element: [3][1]
    Step: 11, Element: [3][2]
    
    ```
    
    The step value increases with every iteration within the inner **for** loop. Because of this, we can see the order in which each element is accessed. If we follow the step value in the output shows us that the elements are accessed in the same order as the row-major diagram above. Now why is that?
    
    This is because in our **for** loop, we are using the number of rows as the termination condition within the outer **for** loop header `a < matrix.length;` Additionally, we are using the number of columns `b < matrix[a].length` as the termination condition for our inner loop. Logically we are saying: “For every row in our matrix, iterate through every single column before moving to the next row”. This is why our above example is traversing the 2D array using row-major order.
    
    Here is a diagram showing which loop accesses which part of the 2D array for row-major order:
    
    ![https://static-assets.codecademy.com/Paths/ap-computer-science/TwoDArrays/row_major_loop.png](https://static-assets.codecademy.com/Paths/ap-computer-science/TwoDArrays/row_major_loop.png)
    
    **Traversing 2D Arrays: Column-Major Order**
    
    Column-major order for 2D arrays refers to a traversal path which moves vertically down each column starting at the first column and ending with the last.
    
    This ordering system also conceptualizes the 2D array into a rectangular matrix and starts the traversal at the top left element and ends at the bottom right element. Column-major order has the same starting and finishing point as row-major order, but it’s traversal is completely different
    
    In order to perform column-major traversal, we need to set up our nested loops in a different way. We need to change the outer loop from depending on the number of rows, to depending on the number of columns. Likewise we need the inner loop to depend on the number of rows in its termination condition.
    
    Let’s look at our example 2D array from the last exercise and see what needs to be changed.
    
    Given this 2D array of strings describing the element positions:
    
    ```
    String[][] matrix = {{"[0][0]", "[0][1]", "[0][2]"},
                         {"[1][0]", "[1][1]", "[1][2]"},
                         {"[2][0]", "[2][1]", "[2][2]"},
                         {"[3][0]", "[3][1]", "[3][2]"}};
    
    ```
    
    Let’s keep track of the total number of iterations as we traverse the 2D array. We also need to change the termination condition (middle section) within the outer and inner **for** loop.
    
    ```
    int stepCount = 0;
    
    for(int a = 0; a < matrix[0].length; a++) {
        for(int b = 0; b < matrix.length; b++) {
            System.out.print("Step: " + stepCount);
            System.out.print(", Element: " + matrix[b][a]);
            System.out.println();
            stepCount++;
        }
    }
    
    ```
    
    Here is the output of the above code:
    
    ```
    Step: 0, Element: [0][0]
    Step: 1, Element: [1][0]
    Step: 2, Element: [2][0]
    Step: 3, Element: [3][0]
    Step: 4, Element: [0][1]
    Step: 5, Element: [1][1]
    Step: 6, Element: [2][1]
    Step: 7, Element: [3][1]
    Step: 8, Element: [0][2]
    Step: 9, Element: [1][2]
    Step: 10, Element: [2][2]
    Step: 11, Element: [3][2]
    
    ```

    **Combining Traversal and Conditional Logic**
    
    When working with 2D arrays, it is important to be able to combine traversal logic with conditional logic in order to effectively navigate and process the data. Here are a few ways in how conditional logic can affect 2D array traversal:
    
    - Skipping or selecting certain rows and columns
    - Modifying elements only if they meet certain conditions
    - Complex calculations using the 2D array data
    - Formatting the 2D array
    - Avoiding exceptions / smart processing
    
    Let’s go over a few examples which use these ideas:
    
    First, let’s think about a situation where you have some string data inside a 2D array. We have an application which allows users to input events on a calendar. This is represented by a 5x7 2D array of strings. Due to the fact that the number of days in each month is slightly different and that there are less than 35 days in a month, we know that some of our elements are going to be empty. We want our application to do a few things:
    
    - Detect which days of which weeks have something planned and alert us about the event.
    - Count the number of events for each week
    - Count the number of events for each day
    
    Here is a visualization of what our calendar data looks like after a user has entered in some event information:
    
    ![https://static-assets.codecademy.com/Paths/ap-computer-science/TwoDArrays/calendar.png](https://static-assets.codecademy.com/Paths/ap-computer-science/TwoDArrays/calendar.png)
    
    Here’s what our calendar data looks like in our application
    
    ```
    String[][] calendar = {{"volunteer", "delivery", null, null, "doctor", null, "soccer"}, {null, "exam 1", null, "mechanic", null, null, "soccer"}, {"volunteer", "off work", null, "birthday", null, "concert", null}, {null, "exam 2", null, null, "doctor", null, "soccer"}, {"visit family", null, null, null, null, null, null}};
    
    ```
    
    Let’s look at some code which accomplishes the requirements above. Carefully look through each line of code and read all of the comments.
    
    There are a few things to note:
    
    - Row-major or column-major order can be used to access the individual events
    - Row-major order must be used to count the number of events per week since each row represents a week
    
    Let’s take care of the first 2 requirements in one set of nested row-major loops
    
    ```
    for(int i = 0; i < calendar.length; i++) {
        numberOfEventsPerWeek = 0;
        for(int j = 0; j < calendar[i].length; j++) {
            // We need conditional logic to ensure that we do not count the empty days
            String event = calendar[i][j];
            if(event!=null && !event.equals("")) {
                // If the day does not have a null value and an empty string for an event, then we print it and count it
                System.out.println("Week: " + (i+1) + ", Day: " + (j+1) + ", Event: " + event);
                numberOfEventsPerWeek++;
            }
        }
        System.out.println("Total number of events for week "+ (i+1) +": " + numberOfEventsPerWeek + "\n");
    }
    
    ```
    
    The above code produces this output:
    
    ```
    Week: 1, Day: 1, Event: volunteer
    Week: 1, Day: 2, Event: delivery
    Week: 1, Day: 5, Event: doctor
    Week: 1, Day: 7, Event: soccer
    Total number of events for week 1: 4
    
    Week: 2, Day: 2, Event: exam 1
    Week: 2, Day: 4, Event: mechanic
    Week: 2, Day: 7, Event: soccer
    Total number of events for week 2: 3
    
    Week: 3, Day: 1, Event: volunteer
    Week: 3, Day: 2, Event: off work
    Week: 3, Day: 4, Event: birthday
    Week: 3, Day: 6, Event: concert
    Total number of events for week 3: 4
    
    Week: 4, Day: 2, Event: exam 2
    Week: 4, Day: 5, Event: doctor
    Week: 4, Day: 7, Event: soccer
    Total number of events for week 4: 3
    
    Week: 5, Day: 1, Event: visit family
    Total number of events for week 5: 1
    
    ```
    
    Now let’s complete the third requirement. Since we need to count all of the events for each of the weekdays, we will need to traverse the calendar vertically.
    
    ```
    int numberOfEventsPerWeekday = 0;
    // We will use this array of day strings for our output later on so we don't have (day: 1)
    String[] days = {"Sundays", "Mondays", "Tuesdays", "Wednesdays", "Thursdays", "Fridays", "Saturdays"};
    for(int i = 0; i < calendar[0].length; i++) {
        numberOfEventsPerWeekday = 0;
        for(int j = 0; j < calendar.length; j++) {
            // Don't forget to flip the iterators in the accessor since we are flipping the direction we are navigating.
            // Remember, i now controls columns and j now controls rows
            String event = calendar[j][i];
            if(event!=null && !event.equals("")) {
                // Make sure we have an event for the day before counting it
                numberOfEventsPerWeekday++;
            }
        }
        // Use the days string array from earlier to convert the day index to a real weekday string
        System.out.println("Number of events on " + days[i] + ": " + numberOfEventsPerWeekday);
    }
    
    ```
    
    The output is:
    
    ```
    Number of events on Sundays: 3
    Number of events on Mondays: 4
    Number of events on Tuesdays: 0
    Number of events on Wednesdays: 2
    Number of events on Thursdays: 2
    Number of events on Fridays: 1
    Number of events on Saturdays: 3
    
    ```
    
    This example uses many of the concepts we have learned before. We use row-major order, column-major order, as well as including conditional logic to ensure that we have data for the elements we are accessing.
    
    Additionally, we can use conditional logic to skip portions of the 2D array. For example, let’s say we wanted to print the events for weekdays only and skip the weekends.
    
    We could use a conditional statement such as `if(j!=0 && j!=6)` in order to skip Sunday (`0`) and Saturday (`6`).
    
    These modifications to our 2D array traversal are very common when processing data in applications. We need to know which cells to look at (skipping column titles for example), which cells to ignore (empty data, invalid data, outliers, etc.), and which cells to convert (converting string input from a file to numbers).
